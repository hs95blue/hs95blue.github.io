- ORM기술(Object Relation Mapping)
JPA
하이버네이트

<br/><br/><br/><br/>

# 스프링 탄생배경
- EJB -자바진영의 표준기술
Enterprise Java Beans
- 분산시스템 구축을 돕는다는 장점이 있으나 어렵고 복잡하고 느림  
(분산시스템은 로직의 재활용성, 시스템구조의 유연성을 얻기위함)  
ex)네트워크 통신, 데이터베이스 통신 
- 종속성이 강함.EJB 컨테이너에서만 동작가능(코드 상에서 EJB만의 요구사항이 있었음.)
- 컨테이너 하나띄우는데도 오래걸림  
  (자동화를 위해 여러로직을 실행-> 느려짐,자원도 많이 잡아먹음)
- 코드지저분해짐(쿼리하나에도 연동하는 코드를 짜야하는 등.)
- 단위테스트가 어려움. 테스트할 때마다 컨테이너에 전체코드를 배포해야했음.  
> 종속성이 너무 강해 코드가 지저분해지고 객체지향개념과 거리가 멀었음

<br/>
 
# EJB를 비판한 Spring  
<br/>

- POJO(Plain Old Java Object)  
  오래된 방식의 간단한 자바 오브젝트
- EJB라는 겨울이 끝나고 새로운 시작이라는 뜻에서 Spring이라고 이름지음.
<br/><br/>

# 왜 스프링인가?
- 경량 컨테이너
- POJO -> EJB처럼 요구되는 특정한 인터페이스 없이 기존에 존재하는 라이브러리로 구현가능
- IoC(제어반전)- 객체의 라이프 사이클을 스프링이 제어하여 개발자의 실수를 미연에 방지
- DI 컨테이너 제공   
->의존성 주입, 프레임워크가 각각의 계층이나 서비스를 연결.  
인터페이스만 있으면 됨. 
- AOP(관점 지향 프로그래밍)- 비즈니스 로직과는 관련이 없지만 공통적으로 쓰이는 기능들을 분리해 개발하고, 실행시에 조합가능
> 쉽게 부품을 교체하듯 개발 가능 
> 
 <br/><br/>

# 스프링 프레임워크
- DI 기술, 웹기술, 데이터 접근 기술 등등 다양한 기술들을 편리하게 사용하도록 해주는 도구.

<br/><br/>

# 스프링 부트의 출현

- 스프링은 설정자체가 힘듬.설정이 절반이다
- 웹서버를 연동하는게 힘들었음  
<br/><br/>

# 스프링부트
- 별도의 웹서버 설치 필요 없음 
- 단독으로 실행가능
- 손쉬운 빌드 구성을 위해 Starter 종속성 제공 - 필요한 외부 라이브러리를 끌어와줌
- 호환성 맞추기 힘든 부분을 해결
- 설정이 기본적으로 되어있고, 필요할때 커스텀 가능  

스프링 데이터 -CRUD를 편리하게 해줌  
스프링세션 - 세션기능 편리하게  
스프링 시큐리티- 보안관련   
스프링 Rest Docs- API 문서화 편하게  
스프링 배치 - 배치처리 특화  
스프링 클라우드 - 클라우드 기술에 특화  
<br/><br/>

## 스프링
- 스프링 DI 컨테이너 기술
- 스프링 프레임워크 자체
<br/><br/>


## 스프링을 만든이유
- 자바 기반
- 객체지향
> 좋은 객체지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크
 
<br/><br/>


# 객체지향 프로그래밍이란?
- 컴퓨터 프로그램을 객체들의 모임으로 파악하고자 하는것
- 각각의 객체는 메시지를 주고받고 데이터를 처리할 수 있음
- 유연하고 변경이 용이 

> 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법 -> **다형성**
> 
<br/><br/>

# 객체지향 특징
- 추상화 -구현 세부사항과 동작을 분리 ex) 인터페이스
- 캡슐화 -비슷한 역할을 하는 속성과 메소드들을 하나의 클래스로 모은 것  
  -> 내부구현에 유연성 부여,변경의 파급력 낮춤
- 상속 - 클래스를 재사용하는것
- 다형성 -같은모양의 인터페이스나 메소드가 상황에 따라 다르게 동작하는 것
<br/><br/>

# 다형성
- 역할과 구현
> 클라이언트에 영향을 주지않고 새로운 기능을 제공 가능(유지보수 용이)  

<br/>
 
## 운전자-자동차 예시 
-  클라이언트는 대상의 역할(인터페이스)만 알면된다.
-  클라이언트는 구현대상의 내부구조를 몰라도 된다.
-  클라이언트는 구현대상의 내부 구조가 변경되어도 영향을 받지않는다.
-  클라이언트는 구현대상 자체를 변경해도 영향받지않는다.

<br/>  

- 역할 -> 인터페이스      
- 구현 -> 인터페이스를 구현한 클래스, 구현객체
  
  - 역할을 부여하고 그 역할을 수행하는 구현객체 만들기  
  - 클라이언트 **요청**   
  - 서버 **응답**  
>  수많은 객체 클라이언트와 객체 서버는 서로 협력관계를 가진다.

<br/><br/>

# 자바언어의 다형성

- 오버라이딩- 인터페이스가 작성된 객체를 실행시점에 유연하게 변경할 수 있다.

> 다형성의 본질 - 클라이언트를 변경하지 않고, 서버의 구현기능을 유연하게 변경할 수있다
> 
<br/><br/>

# 정리
- 실세계의 역할과 구현이라는 편리한 컨셉을 다형성을 통해 객체 세상으로 가져올수 있음
- 유연하고, 변경이 용이
- 확장가능한 설계
- 클라이언트에 영향 X
- 인터페이스를 안정적으로 잘 설계하는 것이 중요

> 스프링은 다형성을 극대화해서 이용할 수 있게 도와줌  
IoC, DI는 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원.

<br/><br/>

# 좋은 객체지향설계의 5가지 원칙 SOLID

**1.**  SRP-단일 책임원칙
  - 한 클래스는 하나의 책임만 가져야 한다.
  - 변경이 있을때 파급효과가 적으면 단일 책임 원칙을 잘 따른 것  
  ex) UI 변경, 객체의 생성과 사용을 분리
  > 적절하게 잘조절해야함.

**2.** OCP- 개방-폐쇄 원칙
  - 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야한다.
  - 다형성을 활용하면 가능

  - But,구현객체를 바꾸려면 클라이언트 코드를 변경해야한다.  
    객체를 생성하고 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.
> 스프링 컨테이너가 필요한 이유.

**3.** LSP 리스코프 치환원칙
- 하위타입의 인스턴스로 바꾸더라도 프로그램의 정확성이 깨지지않아야한다.
- 인터페이스 규약을 지켜야함.
- 자동차의 악셀 예시
> 지켜지지않으면 개발자가 항상 코드를 다시 들여다봐야함.

**4.** ISP 인터페이스 분리원칙
- 특정 클라이언트를 위한 인터페이스 여러개가 범용인터페이스 하나보다 낫다
  - 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스 분리
  - 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
> 인터페이스가 명확해지고, 대체 가능성이 높아진다.

**5.** DIP 의존관계 역전원칙 
- 추상화에 의존해야, 구체화에 의존 하면 X.
- 클라이언트가 인터페이스만 바라봐야한다
구현클래스도 적어놓으면 구체화에도 의존하는것.
<br/><br/>

 ```JAVA  
  public class MemberService {
 private MemberRepository memberRepository = new MemoryMemberRepository();
}
  ```

  ```JAVA  
  public class MemberService {
// private MemberRepository memberRepository = new MemoryMemberRepository();
private MemberRepository memberRepository = new JdbcMemberRepository();

}
  ```

> 다형성 만으로는 부품을 갈아끼우듯이 개발할 수 없다.
> OCP, DIP 지킬수 없음

<br/><br/>

# 스프링의 역할 정리
- 스프링은 다형성 + OCP,DIP가 가능하게 지원해줌
  - DI: 의존관계, 의존성 주입
  - DI 컨테이너 제공
- 클라이언트 코드의 변경없이 기능확장
- 쉽게 부품 교체하듯 개발가능
- 인터페이스를 먼저 설계하면 구현기술이 바뀌더라도 나머지를 변경할 필요가없다는 장점이 있음.

> 추상화됨으로써 오는 단점- 구현클래스가 뭔지 확인해봐야함.  
 확장가능한 요소는 인터페이스로, 아닌것은 바로구현.



<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>





# 역할과 구현

- 역할과 구현을 나누는 사고방식이 중요
- 인터페이스와 구현에 대한 이해

<img src="https://user-images.githubusercontent.com/45806836/108719856-6d3f2900-7563-11eb-9dbf-5101ce449afd.png" width ="50%" >

<br/>
<br/>

# 관심사 분리

- 로미오와 줄리엣 예시
> 각각의 역할에 대한 구현은 제3자가 해주어야 함.

- SRP 단일 책임 원칙
    - 관심사 분리로 인터페이스는 실행, config클래스는 연결, impl은 구현만 담당
- DIP 의존관계 역전원칙
    - 클라이언트가 인터페이스만 바라보게 
- OCP 개방폐쇄원칙
  - 확장엔 열려있고, 변경엔 닫혀있도록

> 객체지향의 목적을 따라가다보면 자연히 지키게 되는 원칙이라는 생각이듬.

<br/>

# 단위테스트

- 비즈니스 로직에 집중하는 시간도 부족한데 무슨 테스트를 작성하는가?
- 이것도 나중에 유지보수가 되어져야하니 부담스럽다
- 귀찮다  

<br/>

**단위테스트**
```java
class OrderServiceTest {

    MemberService memberService = new MemberServiceImpl();
    OrderService orderService = new OrderServiceImpl();

    @Test
    void createOrder() {
        Long memberId = 1L;
        Member member = new Member(memberId, "jeongwon", Grade.VIP);
        memberService.join(member);

        Order order = orderService.createOrder(memberId, "Spring", 9000);
        Assertions.assertThat(order.getMemberId()).isEqualTo(memberId);
        Assertions.assertThat(order.getDiscountPrice()).isEqualTo(1000);
    }
}  
```

<br/>

## **테스트의 종류**
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbFRtWy%2FbtqCsGRA5PS%2FwOe5BOofN9KXX7hNnbFRNk%2Fimg.png" width="50%">  

<br/>

- 통합 테스트 : 여러 작업 단위가 연계된 워크플로우를 테스트 하기 위한 수단(객체 간, 서비스 간, 시스템 간)
- 기능 테스트 : 공개된 API의 가장 바깥쪽에 해당하는 코드 검사( Controller 호출, Security, http )
- 부하 테스트 : 주어진 단위 시간 동안 어플리케이션이 얼마나 많은 요청을 처리할 수 있는지 검사
- 인수 테스트 : 고객 또는 대리인이 정의되어진 모든 목적에 부합되는지 확인해보고자 하는 검사  
  
## **단위테스트의 종류**
- 논리 단위 테스트 : 한 메서드에 집중한 테스트로 mock이나 stub을 이용해 테스트 메서드의 경계를 제어할 수 있음  
  *mock,stub ->테스트를 위해 임의로 만든 객체
- 통합 단위 테스트 : 실제 운영 환경(혹은 그 일부)에서 컴포넌트 간 연동에 치중한 테스트

## **단위테스트가 필요한 이유******
- 연관컴포넌트의 제작이 완료되지 않더라도 푸쉬 **가능**
    - 큰 프로젝트에서 여러 컴포넌트를 각각 개발하는 경우가 많음.****
    - 그런상황에 서로 다만든다음 테스트 하는 것을 기대할 수 없음.****
    - 단위테스트는 연관컴포넌트없이도 개발이 마무리되었음을 증명가능
- 모든 테스트 같이 실행가능
  - 새로운 기능의 추가 혹은 이전 기능의 수정에 대해 기존 기능이 정상동작하는지 판단 가능
- 리팩토링에 의해 기존의 코드가 망가지지 않는다는 것을 보장함
- 구현 코드의 품질향상, 테스팅이 어렵다면 메서드가 너무 많은 기능을 수행한다는 뜻

















성인 1인 ||





### **시간당 요금**
|1인|2인|
|--:|:--:|
|5만|9만|


# 의존관계 주입
1. 생성자주입  
-생성자 호출시 딱 한번만 호출되는게 보장(그 이후로 변하지않는다는 뜻),  
불변,필수 의존관계에 사용
생성자가 딱하나면 @Autowired를 생략해도 자동주입된다
2. 수정자  
-생성자다음으로 두번째 단계에서 주입됨.  
Autowired가 있어야 주입됨.  
선택적, 변경가능
3. 필드  
    -외부에서 변경이 불가능해서 테스트하기 힘들다는 단점이 있다. 사용하지말자!
   
4. 일반메서드  
   -한번에 여러필드를 주입받을수 있다.  



# MVC 패턴
- Model, View, Controller의 합성어로 소프트웨어 공학에서 사용되는 소프트웨어 **디자인 패턴**  

디자인 패턴이란?
건축으로치면 공법에 해당하는 것으로, 소프트웨어의 개발 방법을 공식화 한 것
구현자들 간의 커뮤니케이션의 효율성을 높이는 기법

### **Model** :   
백그라운드에서 동작하는 로직을 처리 (데이터를 가진 객체, 파라미터로 주로 쓰인다.)DB의 테이블과 대응하는 경우가 많다.)

### **View** :  
 사용자가 보게 될 결과 화면을 출력 (html/css/javascript를 모아둔 컨테이너)

### **Controller** :  
 사용자의 입력처리와 흐름 제어를 담당 (사용자가 접근한 URL에 따라서 사용자의 요청사항을 파악한 후, 그 요청에 맞는 데이터를 Model에 의뢰하고, 데이터를 View에 반영해서 사용자에게 알려준다.)

머신러닝 AI


일은 언제
주업무 기술스펙트럼

팀원 몇명 팀사이즈가 얼만큼 될까요 주니어몇명 시니어몇명


나의 시니어엔지니어 있을건지
영어 실력이 많이 필요할까
하게되면 풀타임으로 하이어링되는건가요
급여는 샐러리는 어떻게될까요
제가 생각해둔건 딱히없다 마켓밸류에 맞춰서 제시해주시면 제가 맞춰서 생각해보면 될것같다
처음에 오피스가 없을건지
그럼 리모트로 하면되는지
읽고쓰는건 어느정도 할줄아는데 말하는건 익숙치가 않아서 힘들다

저는 이전회사 반복적인 단조로운 업무에 지쳐서 그만뒀습니다.
그래서 새로운 기술과 도전에 갈증이 있습니다.
그래서 이 프로젝트가 저에게 좋은 터닝포인트가 되었으면 좋겠고,
적응하는데 시간은 걸리겠지만, 회사에서 꼭 필요한 인재가 되었으면 좋겠습니다. 

저는 자바개발자로 웹SI 회사에서 2년정도 근무한 주니어 개발자입니다
회사는 공공기관 SI회사였구요, Spring framework 기반이었고, 
회사의 admin솔루션을 붙여서 구축하는 일을 주로 했습니다.
스크립트작성, 쿼리작성, 자바 코딩을 주로했습니다.
현재는 퇴사하고, 잠깐 휴식기를 가지면서 취업 목표로 스터디진행하고 있습니다.


제가 가장기억에 남는 프로젝트는 마지막에 진행한 해외전시포탈이라는 
프로젝트인데요,
그 프로젝트는 일단 문제가 굉장히 많았습니다.
처음에는 그 프로젝트를 맡았을때 다른프로젝트와 마찬가지로
ADMIN 솔루션을 갖다 붙이는 작업을 하면을 됐는데요,
그런데 일단 작업에 착수하고 보니까 유지보수 측면에서도 그렇고 속도 면에서도 문제가 굉장히 많았습니다.

예를 들어서 스프링프레임워크 기반이었는데, 스프링의 다형성이나
의존성 주입(디펜던시 인젝션) 그런 스프링의 특징?을 전혀 쓰지않았습니다
예를들면 인터페이스를 쓰지않고 그냥 형식적으로 서비스 클래스에다가 모든로직을 쓴다던지 서비스 클래스가 있는데 컨트롤러단에 로직을 쓴다던지
이런식으로 일관성도 없었고 이제 변수명이런것도 카멜케이스를 따르지않았구요., 그래서 그런 자바코딩하는 측면에서 시니어분과 이야기 했을때 아예 개편을 새로해야겠다는 결론이 났고,그런측면에서 자바코딩을 많이 했습니다.
제일문제는 데이터 테이블 설계가 문제였는데요 그전에는 다른회사가 그사이트를 개발했는데, 테이블에 id값이 있고 그런 구분값에 따라서 새로운 데이터가 들어가야되는데, 새로운사업이 추가될때마다 컬럼을 하나씩 늘려버려서 데이터가 꼬인것도 있고, 그런부분에서 데이터 테이블 개편을 했습니다.

저는
이전회사에서 단조로운 작업들만 반복하면서 새롭고 다양한 기술에 대한 갈증이 생기기도 했습니다. 그게 퇴사한 이유기도 하구요.
아직 커리어와 기술 스펙트럼면에서 아직 방향을 잡는 중이라, 다양한 기업을 고려하고 있

14명팀 