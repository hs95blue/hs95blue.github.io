---
layout: post
title:  스프링프레임워크-7 패턴(Patterns)
date:   2020-09-25 06:35:35 +0300
image:  '/images/spring.png'
tags:   Spring
---
7) 패턴(Patterns)

 

패턴은 말 그대로 어떤 일정한 형태나 양식 또는 유형을 뜻함.

패턴이라는 개념은 스프링 프레임워크에 한정된 것이 아니라 개발 디자인(Development Design)에 대해 사용되는 일반적인 개념 중의 하나.

 

개발 디자인 패턴에는 다음의 2가지가 존재.

 

 * 데코레이터 패턴 :

 타깃의 코드에 손 대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법.
 핵심 코드에 부가적인 기능을 추가하기 위해서 런타임시 다이나믹하게 추가되는 프록시를 사용. 즉 동일한 인터페이스를 구현한 여러 개의 객체를 사용하는 것.
 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴. 기능 확장이 필요할 때 서브클래싱(Subclassing) 대신 쓸 수 있는 유연한 대안이 될 수 있음.
 동적으로 객체의 추가적인 기능들을 가진 객체를 덧붙여 꾸밈.


 

 * 프록시 패턴 :

 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 이용하는 방법.

위의 2가지 패턴의 차이점은 프록시의 경우는 실제 실행될 타깃을 확장하거나 기능을 추가하는 것이 아니라, 단지 타깃에 접근하는 방법 자체를 프록시를 통하여 가능하게 하는 것이고, 데코레이터는 실행 타깃의 확장을 의미함.

 

 

데코레이터 패턴에 대한 예제 코드 : 출처 - 위키피디아 (http://en.wikipedia.org/wiki/Decorator_pattern)

 

// Windows Interface & Simple Window Class

interface Window {

    public void draw();   // draws the Window

    // returns a description of the Window

    public String getDescription();   

}

class SimpleWindow implements Window {

    public void draw() {

        // draw window

    }

    public String getDescription() {

        return "simple window";

    }

}

 

// Decorators
abstract class WindowDecorator implements Window {

    protected Window decoratedWindow; // the Window being decorated

public WindowDecorator (Window decoratedWindow)  {

        this.decoratedWindow = decoratedWindow;

    }

}

class VerticalScrollBarDecorator extends WindowDecorator {

    public VerticalScrollBarDecorator (Window decoratedWindow) {

        super(decoratedWindow);

    }

    public void draw() {

        drawVerticalScrollBar();

        decoratedWindow.draw();

    }

    private void drawVerticalScrollBar() { // draw the vertical scrollbar

    }

    public String getDescription() {

        return decoratedWindow.getDescription() + ", including vertical scrollbars";

    }

}

class HorizontalScrollBarDecorator extends WindowDecorator {

    public HorizontalScrollBarDecorator (Window decoratedWindow) {

        super(decoratedWindow);

    }

    public void draw() {

        drawHorizontalScrollBar();

        decoratedWindow.draw();

    }

    private void drawHorizontalScrollBar() { // draw the horizontal scrollbar

    }

    public String getDescription() {

        return decoratedWindow.getDescription() + ", including horizontal scrollbars";

    }

}

 

 
// Decorator Pattern Example

public class DecoratedWindowTest {

    public static void main(String[] args) {

        // create a decorated Window with horizontal and vertical scrollbars

        Window decoratedWindow = new HorizontalScrollBarDecorator (

                new VerticalScrollBarDecorator(new SimpleWindow()));

 

        // print the Window's description

        System.out.println(decoratedWindow.getDescription());

    }

}

 

윈도우에 대한 인터페이스(interface Window)와 클래스(class SimpleWindow),

그리고 수직 스크롤바가 있는 윈도우 클래스(class VerticalScrollBarDecorator), <- 데코레이터

수평 스크롤바가 있는 윈도우 클래스(class HorizontalScrollBarDecorator) <- 데코레이터

 

기존 윈도우(Simple Window) 클래스를 감싸(implements) 스크롤이 추가된 클래스를 새로 재정의함.

(기존 클래스에 장식(데코레이팅)된 형태로 클래스를 정의)

 

데코레이터 패턴의 단점 :

- 잡다한 클래스가 많아지고, 겹겹이 에워싼 형태의 구조로 구조가 복잡해지면 객체의 정체를 알기 어려움.

 

데코레이터 패턴의 장점 :

- 기존 코드는 수정하지 않고, 확장 및 추가가 가능함.

 

 

패턴의 종류에는 옵저버 패턴, 데코레이터 패턴, 프록시 패턴, 팩토리 패턴, 싱글턴 패턴, 커맨드 패턴, 어댑터 패턴, 퍼사드 패턴, 템플릿 패턴 등등 다양하며 좀 더 자세히 알고 싶은 경우에 Head First Design Patterns (저자 에릭 프리먼) 서적을 추천함.

데코레이터 패턴 위키피디아 : http://en.wikipedia.org/wiki/Decorator_pattern


